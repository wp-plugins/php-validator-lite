<?php

require_once('../../EZ.php');

if (!EZ::isLoggedIn()) {
  http_response_code(400);
  die("Please login before validating files!");
}

require_once 'Tokenizer.php';

$success = $warning = $error = "";
$action = $_REQUEST['action'];
ob_start();
switch ($action) {
  case 'filelist':
    $sources = array_map('trim', explode(',', $_REQUEST['value']));
    break;
  case 'folder':
    $dir = "../../../" . $_REQUEST['value'];
    if (is_dir($dir)) {
      $sources = findFiles($dir);
    }
    else {
      http_response_code(400);
      $error = "Specified folder $dir not found on your server.";
      die($error);
    }
    break;
  case 'file':
    http_response_code(400);
    $error = "Compiling a ZIP archive is available in the <a href='http://buy.thulasidas.com/php-validator' class='goPro'>Pro version</a> of PHP Pseudo Compilier.";
    die($error);
    break;
  case 'plugin':
    http_response_code(400);
    $error = "Validating a plugin is available in the <a href='http://buy.thulasidas.com/php-validator' class='goPro'>Pro version</a> of PHP Pseudo Compilier, when installed as a WordPress plugin.";
    die($error);
    break;
  default:
    $error = "Unknown action!";
    http_response_code(400);
    die($error);
}
$output = validate($sources);
$success = grep('Success: ', $output);
$warning = grep('Warning: ', $output);
$error = grep('Error: ', $output);

ob_end_clean();
http_response_code(200);
header('Content-Type: application/json');
echo json_encode(array('success' => $success, 'warning' => $warning, 'error' => $error));
exit();

function validate($sources) {
  $handlers = array("methods", "functions", "includes", "classes", "defined");
  foreach ($handlers as $h) {
    $$h = array();
  }
  $includePaths = array();
  foreach ($sources as $file) {
    $result = compile($file);
    $path = dirname(realpath(dirname("../../../$file")));
    if (!in_array($path, $includePaths)) {
      $includePaths[] = $path;
    }
    foreach ($handlers as $h) {
      $$h = $$h + $result[$h];
    }
  }
  $testPHP .= "";
  $testPHP .= "set_include_path(get_include_path()";
  foreach ($includePaths as $i) {
    $iPath = trim($i);
    $testPHP .= " . PATH_SEPARATOR . '$iPath'";
  }
  $testPHP .= "); \n";
  $testPHP .= "echo 'Warning: Include Path is ' . get_include_path() . '<br>';\n";
  foreach ($functions as $fun) {
    $f = $fun['text'];
    $f_ = "<span style=\"min-width:150px;display:inline-block;\"><code>$f</code></span>";
    $l = "&emsp;[Called at <code>{$fun['file']}: {$fun['line']}</code>]";
    $testPHP .= "if (!function_exists('$f')) \n{\n\t echo 'Error: Function not found:&emsp; $f_ $l<br>';\n}\n";
    if (!empty(EZ::$options['show_defined'])) {
      $testPHP .= "else {\n\t echo 'Success: Function found:&emsp; $f_ $l<br>';\n }\n";
    }
  }
  foreach ($methods as $meth) {
    $m = $meth['text'];
    $m_ = "<span style=\"min-width:150px;display:inline-block;\"><code>$m</code></span>";
    $l = "&emsp;[Called at <code>{$fun['file']}: {$fun['line']}</code>]";
    $testPHP .= "\$methodExists = false;\n";
    foreach ($classes as $cls) {
      $c = $cls['text'];
      $cm_ = "<span style=\"min-width:200px;display:inline-block;\"><code>$c::$m</code></span>";
      $testPHP .= "if (method_exists('$c', '$m')) {\n\t \$methodExists = true; \n}\n";
      $testPHP .= "if (!\$methodExists) {\n\techo 'Error: Method not found:&emsp; $cm_ $l<br>';\n}\n";
      if (!empty(EZ::$options['show_defined'])) {
        $testPHP .= "else {\n\t  echo 'Success: Method found:&emsp; $cm_ $l<br>';\n }\n";
      }
    }
  }
  $output = "";
  if (!empty(EZ::$options['show_source'])) {
    $output .= "Warning: The auto-generated code is: <pre>" . htmlentities($testPHP) . "</pre>";
  }
  if (!empty(EZ::$options['show_tokens'])) {
    foreach ($handlers as $h) {
      $output .= "Warning: Detected $h:<pre>" . htmlentities(print_r($$h, true)) . "</pre>";
    }
  }
  ob_start();
  eval($testPHP);
  $output .= ob_get_clean();
  return $output;
}

function grep($status, $output) {
  $lines = explode("<br>", $output);
  $found = preg_grep("/^$status/", $lines);
  $found = str_replace($status, "<br>", $found);
  return implode("", $found);
}

function compile($file) {
  $realFile = realpath("../../../" . $file);
  if (empty($realFile)) {
    http_response_code(400);
    die("File <code>$file</code> not found on your server!");
  }
  $tokenizer = Tokenizer::tokenizeFile($realFile);
  $handlers = array("methods", "functions", "includes", "classes", "defined");
  foreach ($handlers as $h) {
    $$h = array();
  }

  $currentClass = false;
  foreach ($tokenizer as $token) {
    list($id, $text, $line, $match) = getList($token);
    $type = $token->getName();
    list($nxId, $nxText, $nxLine, $nxMatch) = getList(getNextToken($tokenizer));
    $gotNxParenthesis = $nxId == '(';
    list($nxNxId, $nxNxText, $nxNxLine, $nxNxMatch) = getList(getNxNextToken($tokenizer));
    $gotNxNxParenthesis = $nxNxId == '(';
    list($pvId, $pvText, $pvLine) = getList(getPrevToken($tokenizer));
    $key = $tokenizer->key();
    if (!empty($currentClass) && $key > $currentClass['end']) {
      $currentClass = false;
    }
    switch ($id) {
      case T_INCLUDE:
      case T_INCLUDE_ONCE:
      case T_REQUIRE:
      case T_REQUIRE_ONCE:
        $nxText = trim($nxText, "\"'");
        $includes[] = array('file' => $file, 'line' => $line,
            'text' => $nxText, 'type' => $type);
        break;
      case T_CLASS: // new class definition
        $currentClass = array('name' => $nxText, 'line' => $line, 'file' => $file,
            'type' => $type, 'start' => $key, 'end' => $nxMatch);
      case T_NEW:
        $classes[] = array('file' => $file, 'line' => $line, 'text' => $nxText,
            'type' => $type);
        break;
      case T_DOUBLE_COLON:
      case T_OBJECT_OPERATOR:
        if ($gotNxNxParenthesis) {
          $methods[] = array('file' => $file, 'line' => $line, 'text' => $nxText,
              'type' => $type, 'class' => $pvText);
          $isMethod = true;
        }
        break;
      case T_STRING:
        if ($gotNxParenthesis) {
          $functions[] = array('file' => $file, 'line' => $line, 'text' => $text,
              'type' => $type);
        }
        break;
      case T_FUNCTION:
        if (!empty($currentClass)) {
          $name = "{$currentClass['name']}::$nxText";
          $value = "Method";
        }
        else {
          $name = $nxText;
          $value = 'Function';
        }
        $defined[$name] = $value;
        break;
    }
  }

  return compact($handlers);
}

function getList($token) {
  if (is_a($token, 'TokenizerToken')) {
    $type = $token->getType();
    $text = $token->__get('content');
    $line = $token->getLine();
    $match = $token->__get('match');
  }
  else {
    $type = $text = $line = $match = "";
  }
  return array($type, $text, $line, $match);
}

function getNextToken($tokenizer) {
  $currentToken = $tokenizer->key();
  $token = $tokenizer->getNextImportantToken();
  $tokenizer->setIndex($currentToken);
  return $token;
}

function getNxNextToken($tokenizer) {
  $currentToken = $tokenizer->key();
  $token = $tokenizer->getNextImportantToken();
  $token = $tokenizer->getNextImportantToken();
  $tokenizer->setIndex($currentToken);
  return $token;
}

function getPrevToken($tokenizer) {
  $currentToken = $tokenizer->key();
  $token = $tokenizer->getPreviousImportantToken();
  $tokenizer->setIndex($currentToken);
  return $token;
}

// Recursively finds all the PHP files in a folder
function findFiles($folder, $extensions = array('php')) {

  function glob_recursive($folder, &$folders = array()) {
    $dirs = glob($folder, GLOB_ONLYDIR | GLOB_NOSORT);
    if (!empty($dirs)) {
      foreach ($dirs as $folder) {
        $folders[] = $folder;
        glob_recursive("{$folder}/*", $folders);
      }
    }
  }

  glob_recursive($folder, $folders);
  $files = array();
  foreach ($folders as $folder) {
    foreach ($extensions as $extension) {
      foreach (glob("{$folder}/*.{$extension}") as $file) {
        $files[] = $file;
      }
    }
  }
  $files= str_replace("../../../", "", $files);
  return $files;
}
